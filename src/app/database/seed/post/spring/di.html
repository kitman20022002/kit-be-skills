<article>
  <h2>1. Where does it come from?</h2>
  <p>
    <strong>Origin</strong>: The concept of Dependency Injection originates from the principle of
    "Inversion of Control" (IoC) in object-oriented programming. The Spring framework adopted this
    concept to alleviate the maintenance burden caused by hard-coded dependencies.
  </p>
  <ul>
    <li>
      <strong>Before its emergence</strong>: Prior to DI, dependencies in objects were typically
      created directly within the object via hardcoding, leading to high coupling and low
      reusability.
    </li>
    <li>
      <strong>After its emergence</strong>: The introduction of DI made managing dependency
      relationships more flexible, reducing coupling between components, and enhancing the
      testability and maintainability of the code.
    </li>
  </ul>

  <h2>2. What is it?</h2>
  <p>
    <strong>Essence</strong>: In the Spring framework, DI is a process that allows objects to define
    their dependencies, which are then provided through constructor parameters, factory method
    parameters, or properties of the object instance.
  </p>
  <ul>
    <li>
      <strong>Decoupling</strong>: DI helps objects to break away from hard-coded dependencies,
      increasing the independence of modules.
    </li>
    <li>
      <strong>Declarative Configuration</strong>: Dependencies can be declared in the Spring
      container via XML or annotations, without altering the class's own code.
    </li>
    <li>
      <strong>Container Management</strong>: Dependency relationships and object lifecycles are
      managed by the Spring container, simplifying the creation and management of objects.
    </li>
  </ul>
  <p><strong>Case Explanation</strong>:</p>
  <ol>
    <li>
      <strong>Background</strong>: Suppose there is a service class that requires a database
      connection.
    </li>
    <li>
      <strong>Solution</strong>: In the Spring framework, the database connection can be injected
      into the service class as a dependency through DI. This way, the service class does not need
      to know how to create the database connection and can focus on its core business logic.
    </li>
  </ol>

  <h2>3. Where is it going?</h2>
  <p>
    <strong>Limitations</strong>: DI can lead to complex configurations, especially in large
    applications, where managing many dependencies can become challenging.
  </p>
  <p>
    <strong>Optimization Direction</strong>: Currently, the industry is moving towards simplifying
    configurations, enhancing the functionality of annotations, and automating dependency
    management.
  </p>
  <p>
    <strong>Future Development</strong>: In the future, DI in Spring might continue to evolve
    towards more automation and intelligence, such as AI-assisted management and optimization of
    dependencies.
  </p>
</article>
